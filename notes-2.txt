This is the second part of the typescript course,
First course is a pre requisite

its better to typescript locally so that you can use different in each
project
once you have downloaded it , you can check it using npx tsc -v

before running npx tsc -w , ensure you have tsconfig.json in root folder

*****Chapter one

Part 1

: in tsconfig.json 
  target = version of js to be used, es5 , es6 etc
           esnext means = use the latest available version
  noEmit = do not produce the transpiled js code if set to true
  outdir = produce the transpiled code , if allowed, to this dire 
  includes = directory of the source ts files to be converted

Part 2 - adding ts to an already existing Js code
added app.js

: in tsconfig 
  allowJs : allow js files to be compiled too
  checkJs : check js files for type error too

: in app.js
  +unary operator converts value to a number, so the type of id should 
  match to number everywhere else

: JSDOC syntax
  this is an industry standard tool for annotating js language
  it is just a comment block with special syntax
  at the top of the js file add /** */ and let vscode autocomplete
  This will help ts to find errors in existing js file without having
  to write the entire code in ts
  It will look something like this : 
        /**
        * 
        * @param {*} contactId //parameter identified from code
        * @returns 
        */ 
   If we replace {*} with number , ts will check if all the params are 
   of type number and will throw an error if not

Part 3 : importing 3rd party apis

: In app.js we have used jquery syntax which is not recognized by ts
  and hence it throws an error. solution
  1. Create a type defination of the api yourself ( dont know how ?)
  2. Use the type defination made by others if library is open source
     search @types/jquery in npmjs.com and copy paste the command to 
     install jsquery's ts defination ( npm install --save @types/jquery)

******Chapter 2

Part 1 : about primitve types - covered in Part 1

Part 2 : custom types using interface - covered in Part 1

: interface defines the structure while classes define both the
  structure and implementation.
  Interfaces are not reflected in the transpiled js while classes do

: Using interface within each other 
    interface Address {
        line1 : string;
        line2? : string;
        district : string;
        state : string;
        pincode : number;
        country : string;
    }

    interface Contact extends Address {
        id : number;
        name: string;
        birthdate? : Date;
    }

Part 3 : Type Alias 

: type ContactName = string // we can use ContactName instead of String
  interface Contact extends Address {
        id : number;
        name: ContactName; 
        birthdate? : Date;
  }
  // if we want to change the type of all references to ContactName
     from string to number, we just need to make 1 change only.
 
Part 4 : Enums - covered in part 1

Part 5 : typing functions - covered in Part 1

Part 6 : generics - covered in Part 1

: some complicated examples 
    interface Contact {
        id : number;
        name: ContactName;
    }

    interface UserContact {
        id : number;
        name : ContactName;
        username : string
    } //usercontact is an extention of Contact

    let primaryContact : Contact = {
        id : 1,
        name : "test User",
    }

    function clone<T1, T2 extends T1>(source: T1): T2{
        return Object.apply({},source); //cloning structure of source
    } // putting a contraint that T2 should be an extention of T1

    const b = clone<Contact, UserContact>(primaryContact)
    //syntax for calling mutiple type tempelate funtion ^
    //if Contact had a property missing in UserContact, this function
    call would throw an error
    //b will be of type UserContact  

: generics can be applied to classes and interfaces too
    interface UserContact<T> {
        id : number
        name : ContactName
        username : T
    }
    const b = clone<Contact, UserContact<string>>(primaryContact)

Challenge 02 :

: This tempelate function excepts an Array of type T.
  Since we are using id property of each object in the Array we need
  to put a constraint on the Type T that it should include 
  an id property 

    function getNextId<T extends {id : number}>(items : T[]) : number {
        return items.reduce((max, x) => x.id > max ? x.id : max, 0) + 1
    }

****Chapter 3

Part 1 

: